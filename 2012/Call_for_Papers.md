---
title: Call for Papers
layout: default2012
---

The 5th International Conference on Software Language Engineering (SLE 2012) 
is devoted to topics related to artificial languages in software engineering. 
SLE's foremost mission is to encourage and organize communication among 
communities that have traditionally looked at software languages from 
different and yet complementary perspectives. Thus, of particular relevance 
to SLE are technologies, methods, experiments, and case studies on software 
languages from modelware, grammarware and ontologyware perspectives. 


### IMPORTANT DATES 

Abstract submission deadline : June 4, 2012 
Article submission deadline : June 11, 2012 
Notification to authors : August 3, 2012 
Camera-ready papers for preproceedings : September 3, 2012 
Camera-ready papers for postproceedings : TBA 


### TYPES OF SUBMISSIONS 

We solicit the following types of papers: 

- Research papers: These should report a substantial research contribution to 
SLE or successful application of SLE techniques or both. Full paper 
submissions must not exceed 20 pages. 

- Industrial experience papers: These papers discuss practical applications 
of SLE technology with an emphasis on the advantages and disadvantages of the 
method, techniques, or tools used. These papers must not exceed 10 pages. 

- Tool demonstration papers: Because of SLE's ample interest in tools, we 
seek papers that present software tools related to the field of SLE. These 
papers will accompany a tool demonstration to be given at the conference. 
These papers must not exceed 10 pages. The selection criteria include the 
originality of the tool, its innovative aspects, the relevance of the tool to 
SLE, and the maturity of the tool. 

Submitted articles must not have been previously published or currently be 
submitted for publication elsewhere. 


### PROCEEDINGS 

All submitted papers will be reviewed by at least three members of the 
program committee. As for previous instances of SLE, all accepted papers will 
be made available at the conference in the pre-proceedings and published in 
the post-proceedings of the conference, which will appear in Springer's 
Lecture Notes in Computer Science series (pending approval). Authors will 
have the opportunity to revise their accepted paper for the pre- and 
post-proceedings. All papers must be formatted according to the Springerâ€™s 
Lecture Notes in Computer Science style. 


### SCOPE 

The term "software language" refers to artificial languages used in software 
development including general-purpose programming languages, domain-specific 
languages, modeling and meta-modeling languages, data models, and ontologies. 
Examples include general purpose modeling languages such as UML, but also 
domain-specific modeling languages for business process modeling, such as 
BPMN, or embedded systems, such as Simulink or Modelica, and specialized 
XML-based and OWL-based languages and vocabularies. The term "software 
language" also comprises APIs and collections of design patterns that define 
a language implicitly. 

Software language engineering is the application of systematic, disciplined, 
and quantifiable approaches to the development (design, implementation, 
testing, deployment), use, and maintenance (evolution, recovery, and 
retirement) of these languages. Of special interest are (1) formal 
descriptions of languages that are used to design or generate language-based 
tools and (2) methods and tools for managing such descriptions, including 
modularization, refactoring, refinement, composition, versioning, 
co-evolution, recovery, and analysis. 


### TOPICS OF INTEREST 

We solicit high-quality contributions in the area of SLE ranging from 
theoretical and conceptual contributions to tools, techniques, and frameworks 
that support the aforementioned lifecycle activities. The topics of interest 
include, but are not limited to the following: 

- Formalisms used in designing and specifying languages and tools that 
analyze language descriptions: Examples are formalisms for grammars, schemas, 
ontologies, and metamodels; tools that detect inconsistencies in metamodels 
or analyze grammars to build a parser; and formal logics and proof assistants 
that verify properties of language specifications. 

- Language implementation techniques: These include advances in traditional 
compiler generator tools such as parser/scanner generators, attribute grammar 
systems, term-rewriting systems, functional-programming-based combinator 
libraries; also of interest are metamodel-based and ontology tools 
implementing constraint, rule, view, transformation, and query formalisms and 
engines. 

- Program and model transformation tools: Examples are tools that support 
program refinement and refactoring, model-based development, aspect and model 
weaving, model extraction, metamodeling, model transformations, reasoning on 
models, round-trip engineering, and runtime system transformation. 

- Composition, integration, and mapping tools for managing different aspects 
of software languages or different manifestations of given language: Examples 
are tools for mapping between the concrete and abstract syntax of a language 
and for managing textual and graphical concrete syntax for the same or 
closely related languages. 

- Transformations and transformation languages between languages and models: 
transformation descriptions and tools or XML/RDF/ontology/object/relational 
mappings; also, reasoning for and about transformations. 

- Language evolution: Included are extensible languages and type systems and 
their supporting tools and language conversion tools. Ontologies and APIs, 
when considered as languages, are subject to evolution; thus tools and 
techniques that assist developers in using a new version of an ontology or an 
API or a competing implementation in a program are also of interest. 

- Approaches to the elicitation, specification, and verification of 
requirements for software languages: Examples include the use of requirements 
engineering techniques in domain engineering and in the development of 
domain-specific languages and the application of logic-based formalisms for 
verifying language and domain requirements. 

- Language development frameworks, methodologies, techniques, best practices, 
and tools for the broader language lifecycle covering phases such as 
analysis, testing, and documentation. For example, frameworks for advanced 
type or reasoning systems, constraint mechanisms, tools for metrics 
collection and language usage analysis, assessing language usability, 
documentation generators, visualization backends, generation of tests for 
language-based tools, knowledge and process management approaches, as well as 
IDE support for many of these activities are of interest. 

- Design challenges in SLE: Example challenges include finding a balance 
between specificity and generality in designing domain-specific languages, 
between strong static typing and weaker yet more flexible type systems, or 
between deep and shallow embedding approaches, as, for example, in the 
context of adding type-safe XML and database programming support to general 
purpose programming languages. 

- Applications of languages including innovative domain-specific languages or 
"little" languages: Examples include policy languages for security or service 
oriented architectures, web-engineering with schema-based generators or 
ontology-based annotations. Of specific interest are the engineering aspects 
of domain-specific language support in all of these cases. 

The program committee chairs encourage potential contributors to contact them 
with questions about the scope and topics of interest of SLE. 


